"use strict";(globalThis.webpackChunk_nand2tetris_web=globalThis.webpackChunk_nand2tetris_web||[]).push([[269],{1269:(a,t,n)=>{n.r(t),n.d(t,{ChipProjects:()=>R,default:()=>T,loadSolutions:()=>C,loaders:()=>M});var o={};n.r(o),n.d(o,{SOLS:()=>A,loadSolutions:()=>s});var u={};n.r(u),n.d(u,{SOLS:()=>D,loadSolutions:()=>b});var d={};n.r(d),n.d(d,{SOLS:()=>h,loadSolutions:()=>i});var l={};n.r(l),n.d(l,{SOLS:()=>E,loadSolutions:()=>r});var e=n(4544);const A={Not:{"Not.hdl":"// REDACTED"},And:{"And.hdl":"CHIP And {\n    IN a, b;\n    OUT out;\n\n    PARTS:\n    Nand(a=a, b=b, out=x);\n    Not(in=x, out=out);\n}"},Or:{"Or.hdl":"// REDACTED"},XOr:{"XOr.hdl":"// REDACTED"},Mux:{"Mux.hdl":"// REDACTED"},DMux:{"DMux.hdl":"// REDACTED"},Not16:{"Not16.hdl":"// REDACTED"},And16:{"And16.hdl":"CHIP And16 {\n    IN a[16], b[16];\n    OUT out[16];\n\n    PARTS:\n    And (a=a[0],  b=b[0],  out=out[0]);\n    And (a=a[1],  b=b[1],  out=out[1]);\n    And (a=a[2],  b=b[2],  out=out[2]);\n    And (a=a[3],  b=b[3],  out=out[3]);\n    And (a=a[4],  b=b[4],  out=out[4]);\n    And (a=a[5],  b=b[5],  out=out[5]);\n    And (a=a[6],  b=b[6],  out=out[6]);\n    And (a=a[7],  b=b[7],  out=out[7]);\n    And (a=a[8],  b=b[8],  out=out[8]);\n    And (a=a[9],  b=b[9],  out=out[9]);\n    And (a=a[10], b=b[10], out=out[10]);\n    And (a=a[11], b=b[11], out=out[11]);\n    And (a=a[12], b=b[12], out=out[12]);\n    And (a=a[13], b=b[13], out=out[13]);\n    And (a=a[14], b=b[14], out=out[14]);\n    And (a=a[15], b=b[15], out=out[15]);\n}"},Or16:{"Or16.hdl":"// REDACTED"},Mux16:{"Mux16.hdl":"// REDACTED"},Mux4Way16:{"Mux4Way16.hdl":"// REDACTED"},Mux8Way16:{"Mux8Way16.hdl":"CHIP Mux8Way16 {\n    IN a[16], b[16], c[16], d[16],\n       e[16], f[16], g[16], h[16],\n       sel[3];\n    OUT out[16];\n\n    PARTS:\n    // Binary tree of 2-way multiplexors\n    Mux16 (a=a,    b=b,    sel=sel[0], out=ab);\n    Mux16 (a=c,    b=d,    sel=sel[0], out=cd);\n    Mux16 (a=e,    b=f,    sel=sel[0], out=ef);\n    Mux16 (a=g,    b=h,    sel=sel[0], out=gh);\n    Mux16 (a=ab,   b=cd,   sel=sel[1], out=abcd);\n    Mux16 (a=ef,   b=gh,   sel=sel[1], out=efgh);\n    Mux16 (a=abcd, b=efgh, sel=sel[2], out=out);\n\n\n// Alternate implementation\n//\n// This implementation replaces the upper two layers of the\n// tree with 4-way multiplexors.\n/*\n    Mux4Way16 (a=a, b=b, c=c, d=d, sel=sel[0..1], out=abcd);\n    Mux4Way16 (a=e, b=f, c=g, d=h, sel=sel[0..1], out=efgh);\n    Mux16     (a=abcd, b=efgh, sel=sel[2], out=out);\n*/\n\n// Alternate implementation\n//\n// Some students make a Mux8Way chip and apply it 16 times as in Not16.\n}"},DMux4Way:{"DMux4Way.hdl":"// REDACTED"},DMux8Way:{"DMux8Way.hdl":"// REDACTED"},Or8Way:{"Or8Way.hdl":"// REDACTED"}};async function s(a){await a.pushd("/projects/01"),await(0,e.cL)(a,A),await a.popd()}const D={HalfAdder:{"HalfAdder.hdl":"// REDACTED"},FullAdder:{"FullAdder.hdl":"// REDACTED"},Add16:{"Add16.hdl":"// REDACTED"},Inc16:{"Inc16.hdl":"// REDACTED"},AluNoStat:{"AluNoStat.hdl":"// REDACTED"},ALU:{"ALU.hdl":"// REDACTED"}};async function b(a){await a.pushd("/projects/02"),await(0,e.cL)(a,D),await a.popd()}const h={Bit:{"Bit.hdl":"CHIP Bit {\n    IN in, load;\n    OUT out;\n\n    PARTS:\n    \n    Mux (a=dffOut, b=in, sel=load, out=muxOut);\n    DFF (in=muxOut, out=dffOut, out=out);\n}"},Register:{"Register.hdl":"// REDACTED"},PC:{"PC.hdl":"// REDACTED"},RAM8:{"RAM8.hdl":"// REDACTED"},RAM64:{"RAM64.hdl":"// REDACTED"},RAM512:{"RAM512.hdl":"// REDACTED"},RAM4k:{"RAM4k.hdl":"// REDACTED"},RAM16k:{"RAM16k.hdl":"// REDACTED"}};async function i(a){await a.pushd("/projects/03"),await(0,e.cL)(a,h),await a.popd()}const E={Memory:{"Memory.hdl":"// REDACTED"},CPU:{"CPU.hdl":"// REDACTED"},Computer:{"Computer.hdl":"// REDACTED"}};async function r(a){await a.pushd("/projects/05"),await(0,e.cL)(a,E),await a.popd()}const R={"01":o,"02":u,"03":d,"05":l};let c=!1;const C=async a=>{c||(c=!0,await s(a),await b(a),await i(a),await r(a),c=!1)},M={loadSolutions:C},T=M}}]);